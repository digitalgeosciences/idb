// Aggregate works.csv into per-program, per-year impact data for charts.
//
// Usage:
//   node scripts/generate-program-impact-by-year.cjs
//
// Reads:
//   data/works.csv (generated by export-works.cjs)
// Writes:
//   src/data/programImpactByYear.generated.ts

const fs = require("fs");
const path = require("path");

const ROOT = path.resolve(__dirname, "..");
const worksCsvPath = path.join(ROOT, "data", "works.csv");
const outPath = path.join(ROOT, "src", "data", "programImpactByYear.generated.ts");

const parseCsvLine = (line) => {
  const result = [];
  let current = "";
  let inQuotes = false;

  for (let i = 0; i < line.length; i += 1) {
    const ch = line[i];

    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (ch === "," && !inQuotes) {
      result.push(current);
      current = "";
      continue;
    }

    current += ch;
  }

  result.push(current);
  return result;
};

const readCsv = (filePath) => {
  if (!fs.existsSync(filePath)) return { headers: [], rows: [] };

  const raw = fs.readFileSync(filePath, "utf8");
  const lines = raw
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  if (lines.length < 2) return { headers: [], rows: [] };

  const headers = parseCsvLine(lines[0]).map((h) => h.trim());
  const rows = lines.slice(1).map((line) => {
    const values = parseCsvLine(line).map((v) => v.trim());
    const record = {};
    headers.forEach((header, idx) => {
      record[header] = values[idx] ?? "";
    });
    return record;
  });

  return { headers, rows };
};

const main = () => {
  const { headers, rows } = readCsv(worksCsvPath);
  if (!headers.length) {
    console.error("No data/works.csv found or file is empty.");
    process.exit(1);
  }

  const lowerHeaders = headers.map((h) => h.toLowerCase());
  const idxWorkId = lowerHeaders.indexOf("work_id");
  const idxProgram = lowerHeaders.indexOf("program");
  const idxYear = lowerHeaders.indexOf("year");
  const idxCitations = lowerHeaders.indexOf("citations");

  if (idxWorkId === -1 || idxProgram === -1 || idxYear === -1 || idxCitations === -1) {
    console.error("data/works.csv must have work_id, program, year, and citations columns.");
    process.exit(1);
  }

  const map = new Map();
  const seenWorks = new Set();

  for (const row of rows) {
    const workId = (row[headers[idxWorkId]] || "").trim();
    const program = (row[headers[idxProgram]] || "").trim();
    const yearNum = Number(row[headers[idxYear]] || "");
    const citationsNum = Number(row[headers[idxCitations]] || "0");

    if (!workId || !program || !Number.isFinite(yearNum) || yearNum <= 0) continue;

    // Avoid double-counting the same work for a given program/year
    const workKey = `${program}:${yearNum}:${workId}`;
    if (seenWorks.has(workKey)) continue;
    seenWorks.add(workKey);

    const key = `${program}:${yearNum}`;
    const existing = map.get(key) || {
      program,
      year: yearNum,
      publications: 0,
      citations: 0,
    };

    existing.publications += 1;
    if (Number.isFinite(citationsNum)) {
      existing.citations += citationsNum;
    }

    map.set(key, existing);
  }

  const records = Array.from(map.values()).sort((a, b) => {
    if (a.program === b.program) return a.year - b.year;
    return a.program.localeCompare(b.program);
  });

  const fileContents = `// AUTO-GENERATED FILE. DO NOT EDIT.\n` +
    `// Generated from data/works.csv by scripts/generate-program-impact-by-year.cjs\n\n` +
    `export interface ProgramYearImpact {\n` +
    `  program: string;\n` +
    `  year: number;\n` +
    `  publications: number;\n` +
    `  citations: number;\n` +
    `}\n\n` +
    `export const programImpactByYear: ProgramYearImpact[] = ${JSON.stringify(records, null, 2)};\n`;

  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, fileContents, "utf8");

  console.log(
    "Generated",
    path.relative(ROOT, outPath),
    "from",
    path.relative(ROOT, worksCsvPath),
  );
};

main();
